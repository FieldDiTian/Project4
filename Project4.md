项目 4，太阳能光伏发电

截止日期：2025 年 12 月 18 日星期四

ME249，2025 年秋季

_[图表及变量说明]_

- $R_{L}$：负载电阻
    
- $V_{L}$：负载电压
    
- $V_{L}=I_{L}R_{L}$
    
- $I_{v}=q_{e}\phi_{g}A$
    
- $I_{L}$：负载电流
    
- 图中标注尺寸：798, 1580, 35 (单位: mm)
    
- **第一部分需要使用的代码文件：**
    
    - `CodeP3.1F25.ipynb`
        
    - `CodeP3.2F25.ipynb`
        
    - `CodeP4.1F25.ipynb`
        

**图 1. 太阳能光伏板设计（单位：毫米）。**

第一部分。

简介

本项目的第一部分考虑上述同类型太阳能电池板设计的性能，该设计曾在项目 2 的第一部分中考虑过。该电池板包含 72 个串联的太阳能电池，每个电池的面积为 173 $cm^{2}$。

提供该类型单元的性能测试数据作为一个数据集，其中包括以下性能参数：

**指定的运行参数：**

- 室外空气温度，$T_{air}(^{\circ}C)$
    
- 入射直接法向太阳辐射强度，$I_{D}(W/m^{2})$
    
- 负载电阻，$R_{L}$ (Ohms)
    

**性能（输出）参数：**

- 电池板对负载的输出电压 $V_{L}$ (V)
    
- 电池板功率输出 $\dot{W}$ (W)
    

任务 4.1.1

为项目 3 提供的包含输入数据 $[T_{air},I_{D},R_{L}]$ 的数据集 CodeP3.1F25.ipynb 包含了太阳辐射通量水平达到 $1300~W/m^{2}$ 的数据。

该文件的副本和骨架代码 CodeP3.2F25.ipynb 可以从项目 3（第 11 周）的 Pages 文档中获取。

为本项目提供的文件 CodeP4.3F25.ipynb 包含了在性能测试中获得的通量高于 1300 $W/m^{2}$ 的数据。

在此任务中，从骨架代码 `CodeP3.2F25.ipynb` 的副本开始，完成以下代码修改：

(a) 将文件 `CodeP3.1F25.ipynb` 中的数据添加到 `CodeP4.1F25.ipynb` 中，以创建一个包含通量高达 $1850~W/m^{2}$ 的所有数据的数据集。

(b) 对于在 (a) 中组装的组合数据集 `CodeP4.1F25.ipynb``，确定每个参数的中位数，并通过将每个参数值除以其中位数来对数据进行归一化。

(c) 取 (b) 中创建的归一化组合数据集，并将其随机分为两个数据集：一个包含 2/3 数据的训练集，和一个包含 1/3 数据的验证集。

(d) 将归一化的训练集数据代入骨架代码 CodeP3.2F25.ipynb 中，并将其转换为一个神经网络模型，该模型可以使用 (c) 中建立的训练数据集进行训练。

对于这第一个模型，使用一个 keras.sequential 网络，具有以下规格：

- 指定一个 RandomUniform 初始化器（见骨架代码）
    
- 一个入口层，有 6 个神经元，激活函数 $=K$，input_shape $=[3]$
    
- 3 个隐藏层，分别有 8、14 和 8 个神经元
    
- 一个出口层，有 2 个神经元，无激活函数
    
- 除了出口层外，所有神经元设置激活函数 $=K$，并使用骨架程序中配置的 RMSprop 优化器。
    

(e) 使用训练数据训练 (d) 部分构建的神经网络模型。在这样做时，建议使用骨架程序中配置的带有反向传播的 model.fit 例程。

如果可能，尝试使平均绝对误差 (mean absolute error) 低于 0.025。

你可以稍微调整初始化和/或学习参数，以尝试改善收敛性。

(f) 将训练好的模型预测值与训练数据集进行比较，报告拟合的平均绝对误差，并为每组数据点运行条件创建一个预测功率输出与数据值功率输出的 $log-log$ 图（包含在你的报告中）。

(g) 重复 (e) 部分的步骤，这次将模型预测值与归一化的验证数据进行比较。

报告平均绝对误差，并在总结报告中包含 (e) 中指定的这些数据的 $log-log$ 图。

(h) 假定空气温度固定在 $20^{\circ}C$，使用本任务中创建的训练好的模型来预测 4 Ohms < $R_{L}$ < 8 Ohms 和 $500<I_{D}<1900~W/m^{2}$ 范围内的太阳能功率输出，并创建一个传递给负载的功率（W，单位瓦特）作为这两个变量函数的曲面图。

任务 4.1.2

复制任务 4.1.1 中创建的代码，并以此为起点，构建并训练一个神经网络模型，其规格与任务 4.1.1 相同，但网络设计有以下更改：

- 使用 4 个隐藏层（而不是 3 个），分别具有 6、9、13 和 7 个神经元。
    

使用这个新模型，重复任务 4.1.1 中的步骤 (e)-(h)，并做这个额外的步骤 (i)：

(i) 将此任务的结果与任务 4.1.1 的结果进行比较，并评估 (1) 该模型是否更好地匹配数据，以及 (2) 是否有任何过拟合的迹象。

在你的报告中总结你的结论。

--- 

## 第二部分

简介
在本项目的第二部分，你将考虑一个由 4 个第一部分描述类型的太阳能电池板组成的太阳能光伏系统。它们将安装在一个紧密间隔的矩形阵列中，但将通过开关接线，以便可以将这四个连接为并联（模式 0），$2\times2$ 串联/并联（模式 1），或四个串联（模式 2）。如图 2 所示，这些变化结合了单个模块的 V-I 特性，产生三种截然不同的整体系统 V-I 特性。

**使用的文件：**

- **第一部分**
    
    - `CodeP3.1F25.ipynb`
        
    - `CodeP3.2F25.ipynb`
        
    - `CodeP4.1F25.ipynb`
        
- **第二部分**
    
    - `CodeP4.2F25.ipynb`
        
    - `CodeP4.3F25.ipynb`
        
    - `CodeP4.4F25.ipynb`
        

_[图 2 内容描述]_

- (0) 4 in parallel (4 个并联) -> 对应的 V-I 曲线平坦且电流大。
    
- (1) $2\times2$ in series/parallel (2x2 串并联) -> 对应的 V-I 曲线适中。
    
- (2) 4 in series (4 个串联) -> 对应的 V-I 曲线电压高。
    

**图 2. 不同模式下的四光伏板系统。**

系统的性能数据可以在以下操作参数的指定值下获得：

- 室外空气温度，$T_{air}(^{\circ}C)$
    
- 入射直接法向太阳辐射强度，$I_{D}(W/m^{2})$
    
- 负载电阻，$R_{L}$ (Ohms)
    

可以在所有三种模式下测试系统，以确定哪种模式（0、1 或 2）提供最高的功率输出。

此类测试的性能数据输出可能是：

- 提供最大功率的模式编号 $M_{max}$（0、1 或 2）
    
- 该最大模式下的系统功率输出 $\dot{W}_{max}$ (W)
    

对于该系统，目标是开发并评估一个基于机器学习的模型，该模型能够预测在指定的一组运行条件下哪种模式将产生最大的功率。

具体而言，目标是使用预测最大性能模式编号 $M_{max}$ 和该模式下太阳能光伏板输出功率 $\dot{W}_{max}$ 的模型，在给定的一组运行条件 $(T_{air},I_{D},R_{L})$ 下，对光伏系统进行基于模型的控制。

关于如何建立此类模型的细节，以及评估其性能的第二个模型，将在下面的两个任务中描述。

任务 4.2.1

(a) 从骨架代码 CodeP4.2F25.ipynb 开始。此代码类似于早期项目中使用的神经网络代码，但在这里，它指导你使用数据集 CodeP4.3F25.ipynb，其中包含输入数据数组 $[M, T_{air},I_{D},R_{L}]$（注意这包括模式编号 M），输出参数是图 2 中描述的 4 面板系统的负载电压和功率输出 $[V_{L},\dot{W}]$。

除了模式编号外，确定每个参数的中位数，并通过将每个参数值除以其中位数来对数据进行归一化。

不要对模式编号进行归一化。

(b) 取归一化的 `CodeP4.3F25.ipynb` 数据，并将其随机分为两个数据集：一个包含 2/3 数据的训练集，和一个包含 1/3 数据的验证集。

(c) 将归一化的训练数据代入骨架代码 CodeP4.2F25.ipynb 中，并将代码转换为一个可以使用训练数据集进行训练的神经网络模型。

对于此模型，带有归一化 $T_{air}$、$I_{D}$ 和 $R_{L}$ 的 M 应作为输入，并且模型应被训练以匹配 $[V_{L}, \dot{W}]$ 的归一化数据值。

在这里，使用一个顺序网络 (sequential network)，并对输入数量、隐藏层数量和每层神经元数量（包括输出层）做出适当的选择。

基于你构建先前模型的经验做出选择，使网络足够复杂以准确拟合数据，并避免使其过于复杂导致收敛需要极多的迭代次数和/或模型过拟合数据。

务必在最终报告中清楚地记录所有的网络设计选择。

(d) 使用训练数据训练 (c) 部分构建的神经网络模型。

如果可能，尝试使平均绝对误差低于 0.020。

(e) 将训练好的模型预测值与训练数据集进行比较，报告拟合的平均绝对误差，并为每组数据点运行条件创建单独的预测功率输出与数据值功率输出的 $log-log$ 图。

(f) 重复 (e) 部分的步骤，这次将模型预测值与归一化的验证数据进行比较。

报告平均绝对误差，并在总结报告中包含 (e) 中指定的 $log-log$ 图。


任务 4.2.2

对于此任务，目标是创建并训练一个神经网络，该网络可以预测在给定输入条件下最大化功率输出的模式编号（分类）。

该预测可以提供给控制系统，控制系统可以设置开关，使系统处于最高效的模式。

使用骨架代码 CodeP4.4F25.ipynb 作为起点，并按照以下步骤构建和训练神经网络模型以预测最大功率模式。

(a) 注意，在第一个单元格中，安装了数组以便它们提供归一化的空气温度 (deg C)、太阳能输入 $(W/sqm)$ 和负载电阻 (ohms) 作为输入，输出数组包含提供最大功率输出的模式编号 $M_{maxint}$。

作为第一步，你必须确定输入变量的适当特定中位数，并替换骨架程序中 Tamed、IDmed 和 RLmed 的虚拟值。

不要对模式编号进行归一化。

(b) 下一步，你必须用一个表示类别 0、1、2 的独热编码 (one-hot encoding) 数组替换 ydata 数组。

具体来说，你替换：

- `[0.]` 为 `[1, 0, 0]`
    
- `[1.]` 为 `[0, 1, 0]`
    
- [2.] 为 [0, 0, 1]
    
    并将输出数组重命名为 ydataCatOHE。注意输入和输出数组会被打印出来，所以检查打印的值以确保你的更改正常工作。
    
    还要注意，你必须将 xdata 和 ydataCatOHE 转换为 numpy 数组 xdataarray 和 ydataCatOHEarray。
    

(c) 取组合的 xdataarray 和 ydataCatOHEarray 数组中的数据，将其随机分为两个数据集：一个包含 3/4 数据的训练集，和一个包含 1/4 数据的验证集。

给数组命名为：

- `X` ~ 包含训练集输入数据的 numpy 数组
    
- `train_label` ~ 包含训练集独热编码类别数据的 numpy 数组
    
- `valid_X` ~ 包含验证集输入数据的 numpy 数组
    
- `valid_label` ~ 包含验证集（原文误写为训练集）独热编码类别数据的 numpy 数组
    

你可以使用 scikit-learn 工具来完成此操作，而不是手动进行。

要遵循此路径，请将下面指示的代码添加到第一个单元格中紧接在注释 #ADD CODE TO PARTITION THE DATA HERE 之后的位置。

描述：

这是要添加的代码：

手动或使用项目中的代码

Python

```
#make sure scikit-learn (vers 1.0.2 or later) is installed
#in your python 3.7 environment
from sklearn.model_selection import train_test_split
train_X, valid_X, train_label, valid_label = train_test_split(xdataarray,
ydataCatOHEarray, test_size=0.25, random_state=13)
# print to check the shape of training and validation set
print(train_X.shape, valid_X.shape, train_label.shape, valid_label.shape)
```

Python

```
#you can add these lines of code at the end to see how the labels are #divided between the sets:
print('training OHE labels: ')
print(train_label)
print('validation OHE labels: ')
print(valid_label)
```

在用于划分数据的代码之后，骨架代码设置了类别/种类的数量：

num_classes = 3

(d) 单元格 2 定义了神经网络模型。使用骨架代码中指定的初始化器：

Python

```
#initialize weights with values between -0.2 and 0.5
initializer = keras.initializers.RandomUniform(minval=-0.2, maxval=0.5)
```

单元格 2 中指定神经网络的代码是：

Python

```
model = keras.Sequential([
keras.layers.Dense(13, activation=K.elu, input_shape=[3],
kernel_initializer=initializer),
keras.layers.Dense(26, activation=K.elu, kernel_initializer=initializer),
keras.layers.Dense(13, activation=K.elu, kernel_initializer=initializer),
])
```

层列表是不完整的，因为它需要为分类输出层进行适当的规范。

这里类别/分类的数量是 3 (num_classes = 3)。在顺序模型层列表中，在列表底部添加以下输出层规范：

keras.layers.Dense(num_classes, activation='softmax')

注意这指定了 softmax 激活函数。

(e) 单元格 3 编译模型。完成 compile 语句，使其读作：

Python

```
model.compile(loss=keras.losses.categorical_crossentropy,
optimizer=keras.optimizers.Adam(), metrics=['accuracy'])
```

注意这指定了交叉熵 (crossentropy) 作为损失函数，它将每个输出层神经元的 softmax 输出解释为概率。

它还指定了 Adam 优化器，这是一种自适应学习率优化器。

单元格 3 还打印了模型特征的摘要。

(f) 单元格 4 训练模型。它包括回调函数，以保存前一个项目中使用的最低损失 epoch 的结果。

目标是获得一个训练好的模型，其训练数据集和验证集都具有非常低的损失值。

完成此单元格中的 model.fit 语句，使其读作：

model_train = model.fit(train_X, train_label, epochs=2000, verbose=1, validation_data=(valid_X, valid_label))

(g) 单元格 5 包含可以指定输入参数测试集并使用训练好的模型确定相应的最大功率输出模式 $M_{maxint}$ 的代码。它还包括评估训练模型针对验证集的代码，并报告验证损失和验证准确率。

注意，要使用训练好的模型生成最高功率输出模式 $M_{maxint}$ 的预测，你需要将输入变量 $T_{air}$，$I_{D}$，$R_{L}$ 加载到测试数组中。

对于仅一个输入测试点，代码将输出传递给数组 outpt[0]。

打印时，outpt[0] 看起来像：

[9.9955148e-01 4.4846025e-04 8.5744372e-09]

这三个数字是独热编码和交叉熵损失函数产生的输出。

注意，这表明 $M_{max}$ 为 0 的概率是 0.9955，为 1 的概率是 4.48e-04，为 2 的概率是 8.57e-09。

为了获得最可能的类别作为整数输出，我们使用：

Mmaxint = np.argmax(np.round(outpt[0]))

round 函数将数组中的每个数字四舍五入为最接近的整数，argmax 函数返回最大值的索引（0、1 或 2）。

所以，使用：

Python

```
test = [] #specifies a test input data set
outpt = [] #output of model for test input
test = [[Tair, ID, RL]]
testarray = np.array(test)
outpt = model.predict(testarray)
Mmaxint = np.argmax(np.round(outpt[0]))
```

确定了训练网络预测的、为指定 $T_{air}, I_{D}, R_{L}$ 值提供最大功率输出的模式 `Mmaxint`。

根据需要调整单元格 5 中的代码，以评估训练好的模型并回答以下子部分中的问题：

(h) 完成上述建立模型的步骤后，多次运行 fit 例程，看看是否能使损失低于 0.020。

使用单元格 5 中的代码将训练好的模型预测值与训练数据集进行比较，并报告这些数据的训练模型的损失和准确率。

还将模型预测值与归一化的验证数据进行比较。

确定验证数据的训练模型的损失和准确率。

在你的报告中的表格里总结训练和验证数据的损失和准确率值。

(i) 根据你的结果，该模型是否有过拟合的证据？定量地证明你的结论。

(j) 正如课堂上讨论的那样，可以通过向网络添加 Dropout 层来减少过拟合的趋势。

为了探索这一点，在每个隐藏层之后（不包括输入和输出层）添加一个 Dropout 层。

设置 dropout 概率为 0.25。你的模型定义应该看起来像：
Python

```
model = keras.Sequential([
keras.layers.Dense(13, activation=K.elu,
input_shape=[3], kernel_initializer=initializer),
keras.layers.Dense(26, activation=K.elu, kernel_initializer=initializer),
keras.layers.Dropout(0.25),
keras.layers.Dense(13, activation=K.elu, kernel_initializer=initializer),
keras.layers.Dropout(0.25),
keras.layers.Dense(num_classes, activation='softmax')
])
```

进行此更改后，多次运行 fit 例程，看看是否能使损失低于 0.025。

如果你没有得到太大的效果，你可以尝试稍微增加 dropout 概率，和/或你可以稍微增加隐藏层中的神经元数量（比如，增加到 15, 30, 15）。

将训练好的模型预测值与训练数据集进行比较，并报告这些数据的训练模型的损失和准确率。

还将模型预测值与归一化的验证数据进行比较。确定验证数据的训练模型的损失和准确率。

在你的报告中的表格里总结训练和验证数据的损失和准确率值。

根据你的结果，是否有证据表明添加 dropout 减少了该模型中的过拟合，还是没有太大的区别？定量地证明你的结论。

(k) 此任务的最后一个要素是比较你在本项目第 2 部分中创建的两个模型的预测，以检查任务 4.2.2 模型预测最大功率输出模式编号 $M_{max}$ 的效果如何。

为此：

[k.1] 使用第 2 部分任务 2 的模型来预测下表中运行条件组合 $T_{air}, I_{D}, R_{L}$ 的最大功率输出模式编号 $(M_{max,int})$。

在下表中，记录任务 4.2.2 神经网络模型针对这些条件预测的 $M_{max,int}$ 值。

|**Tair​ (deg, C)**|**ID​ (W/m2)**|**RL​ (Ohms)**|**Mmax,int​ pred by Task 2.2 model**|**W˙ (W) predicted by Task 2.1 model for M=0**|**W˙ (W) predicted by Task 2.1 model for M=1**|**W˙ (W) predicted by Task 2.1 model for M=2**|
|---|---|---|---|---|---|---|
|10.0|200|50.|||||
|20.0|200|130.|||||
|10.0|500|40.|||||
|20.0|500|80.|||||
|20.0|700|30.|||||
|20.|700|55.|||||
|10.0|1000|12.|||||
|20.0|1000|25.|||||
|20.0|1000|39.|||||

[k.2] 然后，对于 $M=0, 1$ 和 2，将表中的每种 $T_{air}, I_{D}$ 和 $R_{L}$ 变量组合输入到任务 2.1 中开发的神经网络模型中，并确定其预测的功率输出 $\dot{W}$。

使用这种方式生成的结果，填写空列，并确定表中 $M_{max,int}$ 值集合的准确率（正确值与总数值的比率）。

根据你从第 2 部分两个任务中获得的结果，在你的报告中总结你的评估：最好的任务 4.2.2 神经网络模型（带或不带 dropout）是否可以准确地控制图 2 中描述的多模式 4 光伏板系统中的开关设置以实现最佳性能。

整个项目 4 任务在合作者之间的分配：

(1) 第 1 部分的数据准备和程序修改

(2) 训练过程和用于比较的计算

(3) 第 1 部分的绘图和结果解释

(4) 第 2 部分的数据准备

(5) 第 2 部分神经网络建模的程序修改

(6) 第 2 部分的结果绘图和分析

(7) 结果和结论的撰写

交付成果：

书面最终报告应包括：

(1) 关于工作如何在合作者之间分配的书面总结。

(2) 对第 1 部分中考虑的两种不同神经网络设计的结果评估和比较。

(3) 第 1 部分和第 2 部分要求的图和表。（不应放在附录中，务必用单位标记坐标轴）

(4) 对第 2 部分中考虑用于系统控制的第一个神经网络设计的可行性评估。

(5) 你的评估和结论应写得清楚，并用定量信息来证明。

(6) 你的程序副本应作为附录附在报告后。

评分将基于：

(1) 分析文档的彻底性，特别是神经网络设计选择背后的逻辑

(2) 解释的准确性和清晰度

(3) 结果评估理由的彻底性和文档记录

**总结报告截止日期：2025 年 12 月 18 日星期四下午 3 点。**